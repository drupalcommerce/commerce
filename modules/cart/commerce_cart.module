<?php
// $Id$

/**
 * @file
 * Implements the shopping cart system and add to cart features.
 *
 * In Drupal Commerce, the shopping cart is really just an order that makes
 * special considerations to associate it with a user and
 */


/**
 * Implements hook_menu().
 */
function commerce_cart_menu() {
  $items = array();

  $items['cart'] = array(
    'title' => 'Shopping cart',
    'page callback' => 'commerce_cart_view',
    'access arguments' => array('access content'),
    'file' => 'includes/commerce_cart.pages.inc',
  );

  $items['checkout'] = array(
    'title' => 'Checkout',
    'page callback' => 'commerce_cart_checkout_router',
    'access arguments' => array('access checkout'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/commerce_cart.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_commerce_order_state_info().
 */
function commerce_cart_commerce_order_state_info() {
  $order_states = array();

  $order_states['cart'] = (object) array(
    'name' => 'cart',
    'title' => t('Shopping cart'),
    'description' => t('Orders in this state have not been completed by the customer yet.'),
    'weight' => -5,
    'default_status' => 'cart',
  );

  return $order_states;
}

/**
 * Implements hook_commerce_order_status_info().
 */
function commerce_cart_commerce_order_status_info() {
  $order_statuses = array();

  $order_statuses['cart'] = (object) array(
    'name' => 'cart',
    'title' => t('Shopping cart'),
    'state' => 'cart',
    'cart' => TRUE,
  );

  return $order_statuses;
}

/**
 * Implements hook_commerce_checkout_pane_info().
 */
function commerce_cart_commerce_checkout_pane_info() {
  $checkout_panes = array();

  $checkout_panes['cart_contents'] = (object) array(
    'title' => t('Shopping cart contents'),
    'base' => 'commerce_cart_contents_pane',
    'file' => 'includes/commerce_cart.checkout_pane.inc',
    'page' => 'checkout',
  );

  return $checkout_panes;
}

/**
 * Implements hook_commerce_checkout_complete().
 */
function commerce_cart_commerce_checkout_complete($form, &$form_state, $order) {
  // Move the cart order ID to a completed order ID.
  if (!empty($_SESSION['commerce_cart_order_id'])) {
    $_SESSION['commerce_cart_completed_orders'][] = $_SESSION['commerce_cart_order_id'];
    unset($_SESSION['commerce_cart_order_id']);
  }
}

/**
 * Implements hook_commerce_line_item_summary_link_info().
 */
function commerce_cart_commerce_line_item_summary_link_info() {
  return array(
    'view_cart' => array(
      'title' => t('View cart'),
      'href' => 'cart',
      'attributes' => array('rel' => 'nofollow'),
      'weight' => 0,
    ),
    'checkout' => array(
      'title' => t('Checkout'),
      'href' => 'checkout',
      'attributes' => array('rel' => 'nofollow'),
      'weight' => 5,
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function commerce_cart_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'commerce_cart') . '/includes/views',
  );
}

/**
 * Implements hook_theme().
 */
function commerce_cart_theme() {
  return array(
    'commerce_cart_empty_block' => array(
      'variables' => array(),
    ),
    'commerce_cart_empty_page' => array(
      'variables' => array(),
    ),
    'commerce_cart_block' => array(
      'variables' => array('order' => NULL, 'contents_view' => NULL),
      'path' => drupal_get_path('module', 'commerce_cart') . '/theme',
      'template' => 'commerce-cart-block',
    ),
    'commerce_cart_form_product_table' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_user_login().
 */
function commerce_cart_user_login(&$edit, $account) {
  // Merge any items in the anonymous cart with the authenticated user's cart.

  // Get the anonymous cart if it exists.
  if ($anonymous_order = commerce_cart_order_load()) {
    // If the anonymous user had any items in the cart, add them to the user's
    // authenticated cart.
    if (!empty($anonymous_order->line_items[LANGUAGE_NONE])) {
      // Add each of the anonymous cart items to the authenticated user's cart.
      $line_item_ids = array();

      foreach ($anonymous_order->line_items[LANGUAGE_NONE] as $line_item_reference) {
        $line_item_ids[] = $line_item_reference['line_item_id'];
      }

      foreach (commerce_line_item_load_multiple($line_item_ids) as $line_item) {
        commerce_cart_product_add($account->uid, $line_item->product[LANGUAGE_NONE][0]['product_id'], $line_item->quantity);
      }

      // Delete the anonymous order from the database and clear the reference.
      commerce_order_delete($anonymous_order->order_id);
      unset($_SESSION['commerce_cart_order_id']);
    }
  }

  // Set the uid for any completed orders if they exist.
  if (!empty($_SESSION['commerce_cart_completed_orders'])) {
    foreach ((array) $_SESSION['commerce_cart_completed_orders'] as $order_id) {
      if ($order = commerce_order_load($order_id)) {
        if ($order->uid == 0) {
          $order->uid = $account->uid;
          commerce_order_save($order);
        }
      }
    }

    unset($_SESSION['commerce_cart_completed_orders']);
  }
}

/**
 * Implements hook_block_info().
 */
function commerce_cart_block_info() {
  $blocks = array();

  // Define the basic shopping cart block and hide it on the checkout pages.
  $blocks['cart'] = array(
    'info' => t('Shopping cart'),
    'cache' => DRUPAL_NO_CACHE,
    'visibility' => 0,
    'pages' => 'checkout*',
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function commerce_cart_block_view($delta) {
  global $user;

  // Prepare the display of the default Shopping Cart block.
  if ($delta == 'cart') {
    // First check for items in the shopping cart.
    $order = commerce_cart_order_load($user->uid);

    // If the cart is empty...
    if (!$order || empty($order->line_items)) {
      // Display an appropriate message.
      $content = theme('commerce_cart_empty_block');
    }
    else {
      // Build the variables array to send to the cart block template.
      $variables = array(
        'order' => $order,
        'contents_view' => commerce_embed_view('commerce_cart_block', 'defaults', array($order->order_id)),
      );

      $content = theme('commerce_cart_block', $variables);
    }

    return array('subject' => t('Shopping cart'), 'content' => $content);
  }
}

/**
 * Themes an empty shopping cart block's contents.
 */
function theme_commerce_cart_empty_block() {
  return '<div class="cart-empty-block">' . t('Your shopping cart is empty.') . '</div>';
}

/**
 * Themes an empty shopping cart page.
 */
function theme_commerce_cart_empty_page() {
  return '<div class="cart-empty-page">' . t('Your shopping cart is empty.') . '</div>';
}

/**
 * Loads the shopping cart order for the specified user.
 *
 * @param $uid
 *   The uid of the customer whose cart to load. If left 0, attempts to load
 *     an anonymous order from the session.
 *
 * @return
 *   The fully loaded shopping cart order or FALSE if non-existent.
 */
function commerce_cart_order_load($uid = 0) {
  // Loaded orders will be cached keyed by $uid.
  $cart_orders = &drupal_static(__FUNCTION__);

  // First return the cached order if it has been loaded already.
  if (!isset($cart_orders[$uid])) {
    $order_id = FALSE;

    // If a customer uid was specified...
    if ($uid) {
      // Create an array of valid shopping cart order statuses.
      $status_ids = array_keys(commerce_order_statuses(array('cart' => TRUE)));

      // Look for the user's most recent shopping cart order, although they
      // should never really have more than one.
      $order_id = db_query('SELECT order_id FROM {commerce_order} WHERE uid = :uid AND status IN (:status_ids) ORDER BY order_id DESC', array(':uid' => $uid, ':status_ids' => $status_ids))->fetchField();
    }
    else {
      // Otherwise look for a shopping cart order ID in the session.
      if (!empty($_SESSION['commerce_cart_order_id'])) {
        $order_id = $_SESSION['commerce_cart_order_id'];
      }
    }

    // If a valid order ID was found, load the order now.
    if ($order_id) {
      $cart_orders[$uid] = commerce_order_load($order_id);
    }
    else {
      $cart_orders[$uid] = FALSE;
    }
  }

  return $cart_orders[$uid];
}

/**
 * Resets the cached array of shopping cart orders.
 */
function commerce_cart_orders_reset() {
  $cart_orders = &drupal_static('commerce_cart_order_load');
  $cart_orders = NULL;
}

/**
 * Creates a new shopping cart order for the specified user.
 *
 * @param $uid
 *   The uid of the user for whom to create the order. If left 0, the order will
 *     be created for the current user and associated with his or her session.
 *
 * @return
 *   The newly created shopping cart order object.
 */
function commerce_cart_order_new($uid = 0) {
  // Create the new order with the customer's uid and the cart order status.
  $order = commerce_order_new($uid, 'cart');
  $order->log = t('Created as a shopping cart order.');

  // Save it so it gets an order ID and return the full object.
  $order = commerce_order_save($order);

  // Reset the cart cache
  commerce_cart_orders_reset();

  // If the user is not logged in, ensure the order ID is stored in the session.
  if (!$uid && empty($_SESSION['commerce_cart_order_id'])) {
    $_SESSION['commerce_cart_order_id'] = $order->order_id;
  }

  return $order;
}

/**
 * Adds the specified product to a customer's shopping cart.
 *
 * @param $uid
 *   The uid of the user whose cart you are adding the product to.
 * @param $product_id
 *   The ID of the product to add to the cart.
 * @param $quantity
 *   The quantity of this product to add to the cart.
 *
 * @return
 *   The entire shopping cart order object or FALSE on failure.
 */
function commerce_cart_product_add($uid, $product_id, $quantity) {
  // Load and validate the specified product ID.
  $product = commerce_product_load($product_id);

  // Fail if the product does not exist or is disabled.
  if (empty($product) || !$product->status) {
    return FALSE;
  }

  // First attempt to load the customer's shopping cart order.
  $order = commerce_cart_order_load($uid);

  // If no order existed, create one now.
  if (empty($order)) {
    $order = commerce_cart_order_new($uid);
  }

  // Determine if the product already exists on the order and increment its
  // quantity instead of adding a new line if it does.
  $line_item_match = NULL;

  // If the order has line items on it...
  if (!empty($order->line_items)) {
    $line_item_ids = array();

    // Build an array of the line item IDs.
    foreach ($order->line_items[LANGUAGE_NONE] as $line_item_reference) {
      $line_item_ids[] = $line_item_reference['line_item_id'];
    }

    // Loop through the line items looking for products.
    foreach (commerce_line_item_load_multiple($line_item_ids) as $line_item) {
      // If this line item matches the product being added...
      if (empty($line_item_match) &&
          $line_item->type == 'product' &&
          $line_item->product[LANGUAGE_NONE][0]['product_id'] == $product_id) {
        // Exit this loop with the $line_item intact so it gets updated.
        $line_item_match = clone($line_item);
      }
    }
  }

  // If no matching line item was found...
  if (empty($line_item_match)) {
    // Create the new product line item.
    $line_item = commerce_product_line_item_new($product, $quantity);

    // Add it to the order's line item reference value.
    $order->line_items[LANGUAGE_NONE][] = array(
      'line_item_id' => $line_item->line_item_id,
    );

    // Save the updated order.
    commerce_order_save($order);
  }
  else {
    // Increment the quantity of the line item and save it.
    $line_item_match->quantity += $quantity;

    commerce_line_item_save($line_item_match);
  }

  // Return the order.
  return $order;
}

/**
 * Builds an appropriate cart form ID based on the products on the form.
 *
 * @see commerce_cart_forms().
 */
function commerce_cart_add_to_cart_form_id($product_ids, $qty = 0) {
  return 'commerce_cart_add_to_cart_form_' . implode('_', $product_ids);
}

/**
 * Implements hook_forms().
 *
 * To provide distinct form IDs for add to cart forms, the product IDs
 * referenced by the form are appended to the base ID,
 * commerce_cart_add_to_cart_form. When such a form is built or submitted, this
 * function will return the proper callback function to use for the given form.
 */
function commerce_cart_forms($form_id, $args) {
  $forms = array();

  // Construct a valid cart form ID from the arguments.
  if (strpos($form_id, 'commerce_cart_add_to_cart_form_') === 0) {
    $forms[$form_id] = array(
      'callback' => 'commerce_cart_add_to_cart_form',
    );
  }

  return $forms;
}

/**
 * Builds an Add to Cart form for a set of products.
 *
 * @param $product_ids
 *   An array of product IDs that will be included in the form.
 * @param $show_quantity
 *   Boolean indicating whether or not the quantity field should be shown;
 *     defaults to FALSE resulting in a hidden field.
 * @param $default_quantity
 *   The value to place in the quantity field, defaults to 1.
 * @param $context
 *   Information on the context of the form's placement, allowing it to update
 *     product fields on the page based on the currently selected default
 *     product. Should be an associative array containing the following keys:
 *     - class_prefix: a prefix used to target HTML containers for replacement
 *       with rendered fields as the default product is updated. For example,
 *       nodes display product fields in their context wrapped in spans with the
 *       class node-#-product-field_name.  The class_prefix for the add to cart
 *       form displayed on a node would be node-# with this form's AJAX refresh
 *       adding the suffix -product-field_name.
 *     - view_mode: a product view mode that tells the AJAX refresh how to
 *       render the replacement fields.
 *     If no context is specified, AJAX replacement of rendered fields will not
 *     happen. This parameter only affects forms containing multiple products.
 *
 * @return
 *   The form array.
 */
function commerce_cart_add_to_cart_form($form, &$form_state, $product_ids, $show_quantity = FALSE, $default_quantity = 1, $context = array()) {
  global $user;

  // Store the form ID as a class of the form to avoid the incrementing form ID
  // from causing the AJAX refresh not to work.
  $form['#attributes']['class'][] = drupal_html_class(commerce_cart_add_to_cart_form_id($product_ids, $default_quantity));

  // Store the customer uid in the form so other modules can override with a
  // selection widget if necessary.
  $form['uid'] = array(
    '#type' => 'value',
    '#value' => $user->uid,
  );

  // Load all the products intended for sale on this form.
  $products = commerce_product_load_multiple($product_ids);

  // If no products were returned...
  if (count($products) == 0) {
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Product not available'),
      '#disabled' => TRUE,
    );
  }
  else {
    $form_state['products'] = $products;

    // If the form is for a single product, store the product_id in a hidden
    // form field for use by the submit handler.
    if (count($products) == 1) {
      $form['product_id'] = array(
        '#type' => 'hidden',
        '#value' => array_shift(array_keys($products)),
      );
    }
    else {
      // However, if more than one products are represented on it, attempt to
      // use smart select boxes for the product selection. If the products are
      // all of the same type and there are qualifying fields on that product
      // type, display their options for customer selection.
      $same_type = TRUE;
      $qualifying_fields = array();
      $type = '';

      // Find the default product so we know how to set default options on the
      // various Add to Cart form widgets and an array of any matching product
      // based on attribute selections so we can add a selection widget.
      $matching_products = array();
      $default_product = NULL;

      foreach ($products as $product_id => $product) {
        // Store the first product type.
        if (empty($type)) {
          $type = $product->type;
        }

        // If the current product type is different from the first, we are not
        // dealing with a set of same typed products.
        if ($product->type != $type) {
          $same_type = FALSE;
        }

        // If the form state contains a set of attribute data, use it to try
        // and determine the default product.
        $changed_attribute = NULL;

        if (!empty($form_state['values']['attributes'])) {
          $match = TRUE;

          foreach ((array) array_diff_key($form_state['values']['attributes'], array('product_select' => '')) as $key => $value) {
            // If this is the attribute widget that was changed...
            if ($value != $form_state['values']['unchanged_attributes'][$key]) {
              // Store the field name.
              $changed_attribute = $key;
            }

            // If a field name has been stored and we've moved past it to
            // compare the next attribute field...
            if (!empty($changed_attribute) && $changed_attribute != $key) {
              // Wipe subsequent values from the form state so they attribute
              // widgets can use the default values from the new default product.
              unset($form_states['values']['attributes'][$key]);
              unset($form_states['values']['unchanged_attributes'][$key]);

              // Don't accept this as a matching product.
              continue;
            }

            if ($product->{$key}[LANGUAGE_NONE][0]['value'] != $value) {
              $match = FALSE;
            }
          }

          // If the changed field name has already been stored, only accept the
          // first matching product by ignoring the rest that would match. An
          // exception is granted for additional matching products that share
          // the exact same attribute values as the first.
          if ($match && !empty($changed_attribute) && !empty($matching_products)) {
            $matching_product = $matching_products[array_shift(array_keys($matching_products))];

            foreach ((array) array_diff_key($form_state['values']['attributes'], array('product_select' => '')) as $key => $value) {
              if ($product->{$key}[LANGUAGE_NONE][0]['value'] != $matching_product->{$key}[LANGUAGE_NONE][0]['value']) {
                $match = FALSE;
              }
            }
          }

          if ($match) {
            $matching_products[$product_id] = $product;
          }
        }
      }

      // Set the default product now if it isn't already set.
      if (empty($matching_products)) {
        // If a product ID value was passed in, use that product if it exists.
        if (!empty($form_state['values']['product_id']) &&
            !empty($products[$form_state['values']['product_id']])) {
          $default_product = $products[$form_state['values']['product_id']];
        }
        else {
          $default_product = $products[array_shift(array_keys($products))];
        }
      }
      else {
        // If the product selector has a value, use that.
        if (!empty($form_state['values']['attributes']['product_select']) &&
            !empty($products[$form_state['values']['attributes']['product_select']]) &&
            in_array($products[$form_state['values']['attributes']['product_select']], $matching_products)) {
          $default_product = $products[$form_state['values']['attributes']['product_select']];
        }
        else {
          $default_product = $matching_products[array_shift(array_keys($matching_products))];
        }
      }

      $form_state['default_product'] = $default_product;
      $form_state['context'] = $context;

      // If all the products are of the same type...
      if ($same_type) {
        // Loop through all the field instances on that product type.
        foreach (field_info_instances('commerce_product', $type) as $name => $instance) {
          // A field qualifies if it is single value, required and uses a widget
          // with a definite set of options. For the sake of simplicity, this is
          // currently restricted to fields defined by the options module.
          $field = field_info_field($instance['field_name']);

          if ($field['cardinality'] == 1 && $instance['required'] && $instance['widget']['module'] == 'options') {
            // Get the options properties from the options module and store the
            // options for the instance in select list format in the array of
            // qualifying fields.
            $properties = _options_properties('select', FALSE, TRUE, TRUE);

            $qualifying_fields[$name] = array(
              'field' => $field,
              'instance' => $instance,
              'options' => _options_get_options($field, $instance, $properties),
              'weight' => $instance['widget']['weight'],
            );
          }
        }
      }

      // Otherwise for products of varying types, display a simple select list
      // by product title.
      if (!empty($qualifying_fields)) {
        $used_options = array();

        // Sort the fields by weight.
        uasort($qualifying_fields, 'drupal_sort_weight');

        foreach ($qualifying_fields as $field_name => $data) {
          // Build an options array of widget options used by referenced products.
          foreach ($products as $product_id => $product) {
            // Only add options to the present array that appear on products that
            // match the default value of the previously added attribute widgets.
            foreach ($used_options as $used_field_name => $unused) {
              // Don't apply this check for the current field being evaluated.
              if ($used_field_name == $field_name) {
                continue;
              }

              if ($product->{$used_field_name}[LANGUAGE_NONE][0]['value'] != $form['attributes'][$used_field_name]['#default_value']) {
                continue 2;
              }
            }

            // With our hard dependency on widgets provided by the Options
            // module, we can make assumptions about where the data is stored.
            $used_options[$field_name][] = $product->{$field_name}[LANGUAGE_NONE][0]['value'];
          }

          // If for some reason no options for this field are used, remove it
          // from the qualifying fields array.
          if (empty($used_options[$field_name])) {
            unset($qualifying_fields[$field_name]);
          }
          else {
            $form['attributes'][$field_name] = array(
              '#type' => 'select',
              '#title' => check_plain($data['instance']['label']),
              '#options' => array_intersect_key($data['options'], drupal_map_assoc($used_options[$field_name])),
              '#default_value' => $default_product->{$field_name}[LANGUAGE_NONE][0]['value'],
              '#weight' => $data['instance']['widget']['weight'],
              '#ajax' => array(
                'callback' => 'commerce_cart_add_to_cart_form_attributes_refresh',
              ),
            );
            $form['unchanged_attributes'][$field_name] = array(
              '#type' => 'value',
              '#value' => $default_product->{$field_name}[LANGUAGE_NONE][0]['value'],
            );
          }
        }

        if (!empty($form['attributes'])) {
          $form['attributes'] += array(
            '#tree' => 'TRUE',
            '#prefix' => '<div class="attribute-widgets">',
            '#suffix' => '</div>',
            '#weight' => 0,
          );
          $form['unchanged_attributes'] += array(
            '#tree' => 'TRUE',
          );

          // If the matching products array is empty, it means this is the first
          // time the form is being built. We should populate it now with
          // products that match the default attribute options.
          if (empty($matching_products)) {
            foreach ($products as $product_id => $product) {
              $match = TRUE;

              foreach (element_children($form['attributes']) as $field_name) {
                if ($product->{$field_name}[LANGUAGE_NONE][0]['value'] != $form['attributes'][$field_name]['#default_value']) {
                  $match = FALSE;
                }
              }

              if ($match) {
                $matching_products[$product_id] = $product;
              }
            }
          }

          // If there were more than one matching products for the current
          // attribute selection, add a product selection widget.
          if (count($matching_products) > 1) {
            $options = array();

            foreach ($matching_products as $product_id => $product) {
              $options[$product_id] = check_plain($product->title);
            }

            $form['attributes']['product_select'] = array(
              '#type' => 'select',
              '#title' => t('Select a product'),
              '#options' => $options,
              '#default_value' => $default_product->product_id,
              '#weight' => 40,
              '#ajax' => array(
                'callback' => 'commerce_cart_add_to_cart_form_attributes_refresh',
              ),
            );
          }

          $form['product_id'] = array(
            '#type' => 'hidden',
            '#value' => $default_product->product_id,
          );
        }
      }

      // If the products referenced were of different types or did not posess
      // any qualifying attribute fields, add a product selection widget.
      if (!$same_type || empty($qualifying_fields)) {
        $options = array();

        foreach ($products as $product_id => $product) {
          $options[$product_id] = check_plain($product->title);
        }

        $form['product_id'] = array(
          '#type' => 'select',
          '#options' => $options,
          '#default_value' => $default_product->product_id,
          '#weight' => 0,
          '#ajax' => array(
            'callback' => 'commerce_cart_add_to_cart_form_attributes_refresh',
          ),
        );
      }
    }

    // Render the quantity field as either a textfield if shown or a hidden
    // field if not.
    if ($show_quantity) {
      $form['quantity'] = array(
        '#type' => 'textfield',
        '#title' => t('Quantity'),
        '#default_value' => $default_quantity,
        '#size' => 5,
        '#weight' => 5,
      );
    }
    else {
      $form['quantity'] = array(
        '#type' => 'hidden',
        '#value' => $default_quantity,
        '#weight' => 5,
      );
    }

    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Add to cart'),
      '#weight' => 10,
    );
  }

  // Add the handlers manually since we're using hook_forms() to associate this
  // form with form IDs based on the $product_ids.
  $form['#validate'][] = 'commerce_cart_add_to_cart_form_validate';
  $form['#submit'][] = 'commerce_cart_add_to_cart_form_submit';

  return $form;
}

/**
 * Form validate handler: validate the product and quantity to add to the cart.
 */
function commerce_cart_add_to_cart_form_validate($form, &$form_state) {
  if (!is_numeric($form_state['values']['quantity']) || $form_state['values']['quantity'] <= 0) {
    form_set_error('quantity', t('You must specify a valid quantity to add to the cart.'));
  }

  // If the attributes matching product selector was used, set the value of the
  // product_id field to match; this will be fixed on rebuild when the actual
  // default product will be selected based on the product selector value.
  if (!empty($form_state['values']['attributes']['product_select'])) {
    form_set_value($form['product_id'], $form_state['values']['attributes']['product_select'], $form_state);
  }
}

/**
 * Ajax callback: returns AJAX commands when an attribute widget is changed.
 */
function commerce_cart_add_to_cart_form_attributes_refresh($form, $form_state) {
  $commands = array();

  // Render the form afresh to capture any changes to the available widgets
  // based on the latest selection.
  $commands[] = ajax_command_replace('.' . str_replace('_', '-', $form['#form_id']), drupal_render($form));

  // Then render and return the various product fields that might need to be
  // updated on the page.
  if (!empty($form_state['context'])) {
    $product = $form_state['default_product'];

    foreach (field_info_instances('commerce_product', $product->type) as $product_field_name => $product_field) {
      $class = drupal_html_class(implode('-', array($form_state['context']['class_prefix'], 'product', $product_field_name)));

      $element = field_view_field('commerce_product', $product, $product_field_name, $form_state['context']['view_mode']);
      $element += array(
        '#prefix' => '<span class="' . $class . '">',
        '#suffix' => '</span>',
      );

      $commands[] = ajax_command_replace('.' . $class, drupal_render($element));
    }
  }

  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * Form submit handler: add the selected product to the cart.
 */
function commerce_cart_add_to_cart_form_submit($form, &$form_state) {
  $product_id = $form_state['values']['product_id'];
  $product = $form_state['products'][$product_id];

  // Add the product to the specified shopping cart.
  commerce_cart_product_add($form_state['values']['uid'], $product_id, $form_state['values']['quantity']);

  // TODO: Accommodate multiple product Add to Cart forms better; i.e. should it
  // display the product title or the product display node title?
  drupal_set_message(t('%title added to <a href="!cart-url">your cart</a>.', array('%title' => $product->title, '!cart-url' => url('cart'))));
}

/**
 * Implements hook_field_formatter_info().
 */
function commerce_cart_field_formatter_info() {
  return array(
    'commerce_cart_add_to_cart_form' => array(
      'label' => t('Add to Cart form'),
      'description' => t('Display an Add to Cart form for the referenced product.'),
      'field types' => array('commerce_product_reference'),
      'settings' => array(
        'show_quantity' => FALSE,
        'default_quantity' => 1,
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function commerce_cart_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $element = array();

  if ($display['type'] == 'commerce_cart_add_to_cart_form') {
    $element['show_quantity'] = array(
      '#type' => 'checkbox',
      '#title' => t('Display a textfield quantity widget on the add to cart form.'),
      '#default_value' => $settings['show_quantity'],
    );

    $element['default_quantity'] = array(
      '#type' => 'textfield',
      '#title' => t('Default quantity'),
      '#default_value' => $settings['default_quantity'] <= 0 ? 1 : $settings['default_quantity'],
      '#element_validate' => array('commerce_cart_field_formatter_settings_form_quantity_validate'),
      '#size' => 16,
    );
  }

  return $element;
}

/**
 * Element validate callback: ensure a valid quantity is entered.
 */
function commerce_cart_field_formatter_settings_form_quantity_validate($element, &$form_state, $form) {
  if (!is_numeric($element['#value']) || $element['#value'] <= 0) {
    form_set_error(implode('][', $element['#parents']), t('You must enter a positive numeric default quantity value.'));
  }
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function commerce_cart_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $summary = array();

  if ($display['type'] == 'commerce_cart_add_to_cart_form') {
    $summary = array(
      t('Quantity widget: !status', array('!status' => $settings['show_quantity'] ? t('Enabled') : t('Disabled'))),
      t('Default quantity: @quantity', array('@quantity' => $settings['default_quantity'])),
    );
  }

  return implode('<br />', $summary);
}

/**
 * Implements hook_field_formatter_view().
 */
function commerce_cart_field_formatter_view($entity_type, $object, $field, $instance, $langcode, $items, $display) {
  $result = array();

  // Collect the list of product IDs.
  $product_ids = array();

  foreach ($items as $delta => $item) {
    $product_ids[$item['product_id']] = $item['product_id'];
  }

  if ($display['type'] == 'commerce_cart_add_to_cart_form') {
    $settings = $display['settings'];

    $result[] = array(
      '#arguments' => array(
        'form_id' => commerce_cart_add_to_cart_form_id($product_ids),
        'product_ids' => $product_ids,
        'show_quantity' => $settings['show_quantity'],
        'default_quantity' => $settings['default_quantity'],
      ),
    );
  }

  return $result;
}

/**
 * Implements hook_field_attach_view_alter().
 *
 * When a field is formatted for display, the display formatter does not know
 * what view mode it is being displayed for. Unfortunately, the Add to Cart form
 * display formatter needs this information when displaying product reference
 * fields on nodes to provide adequate context for product field replacement on
 * multi-value product reference fields. This hook is used to transform a set of
 * arguments into a form using the arguments and the extra context information
 * gleaned from the parameters passed into this function.
 */
function commerce_cart_field_attach_view_alter(&$output, $context) {
  // Loop through the fields passed in looking for any product reference fields
  // formatted with the Add to Cart form display formatter.
  foreach ($output as $field_name => $element) {
    if (!empty($element['#formatter']) && $element['#formatter'] == 'commerce_cart_add_to_cart_form') {
      // Prepare the context information needed by the cart form.
      $context = array();

      // Add the context for displaying product fields in the context of a node
      // that references the product by looking at the entity this product
      // reference field is attached to.
      if ($element['#entity_type'] == 'node') {
        $context = array(
          'class_prefix' => 'node-' . $element['#object']->nid,
          'view_mode' => 'node_' . $element['#view_mode'],
        );
      }

      foreach (element_children($element) as $key) {
        // Extract the drupal_get_form() arguments array from the element.
        $arguments = $element[$key]['#arguments'];

        // Replace the array containing the arguments with the return value of
        // drupal_get_form(). It will be rendered when the rest of the object is
        // rendered for display.
        $output[$field_name][$key] = drupal_get_form($arguments['form_id'], $arguments['product_ids'], $arguments['show_quantity'], $arguments['default_quantity'], $context);
      }
    }
  }
}
